const agentOutput = $input.item.json.output;

// Remove markdown code blocks
let cleaned = typeof agentOutput === 'string'
  ? agentOutput.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim()
  : JSON.stringify(agentOutput);

console.log('üìù Tamanho do output:', cleaned.length);

// ‚úÖ FOR√áA FECHAMENTO DE JSON TRUNCADO
function forceCloseJSON(jsonStr) {
  console.log('üîß For√ßando fechamento de JSON truncado...');

  // Encontrar √∫ltima linha v√°lida
  const lines = jsonStr.split('\n');
  let validJSON = '';
  let lastValidLine = -1;

  // Percorrer de tr√°s pra frente para encontrar √∫ltima propriedade completa
  for (let i = lines.length - 1; i >= 0; i--) {
    const line = lines[i].trim();

    // Ignorar linhas vazias ou incompletas
    if (!line || line === '{' || line === '[' || line === ',') continue;

    // Se termina com v√≠rgula ou aspas, pode ser v√°lida
    if (line.match(/[",\}\]]$/)) {
      lastValidLine = i;
      break;
    }
  }

  // Reconstruir at√© a √∫ltima linha v√°lida
  if (lastValidLine > 0) {
    validJSON = lines.slice(0, lastValidLine + 1).join('\n');

    // Remover v√≠rgula final se existir
    validJSON = validJSON.replace(/,(\s*[\}\]])$/, '$1');
  } else {
    validJSON = jsonStr;
  }

  // Contar estruturas abertas
  let openBraces = 0;
  let closeBraces = 0;
  let openBrackets = 0;
  let closeBrackets = 0;
  let inString = false;
  let escaped = false;

  for (let i = 0; i < validJSON.length; i++) {
    const char = validJSON[i];

    if (char === '\\' && !escaped) {
      escaped = true;
      continue;
    }

    if (char === '"' && !escaped) {
      inString = !inString;
    }

    if (!inString) {
      if (char === '{') openBraces++;
      if (char === '}') closeBraces++;
      if (char === '[') openBrackets++;
      if (char === ']') closeBrackets++;
    }

    escaped = false;
  }

  console.log('üìä Estruturas:', {
    braces: `${openBraces} abertos, ${closeBraces} fechados`,
    brackets: `${openBrackets} abertos, ${closeBrackets} fechados`
  });

  // Fechar o que falta
  let closers = '';

  // Se tem string aberta, fechar
  const quoteCount = (validJSON.match(/"/g) || []).length;
  if (quoteCount % 2 !== 0) {
    console.log('‚ö†Ô∏è String aberta - fechando com aspas');
    closers += '"';
  }

  // Fechar arrays primeiro (mais interno)
  if (openBrackets > closeBrackets) {
    const diff = openBrackets - closeBrackets;
    console.log(`‚ö†Ô∏è Faltam ${diff} colchetes - fechando arrays`);
    closers += '\n' + '    ]'.repeat(diff);
  }

  // Depois fechar objetos
  if (openBraces > closeBraces) {
    const diff = openBraces - closeBraces;
    console.log(`‚ö†Ô∏è Faltam ${diff} chaves - fechando objetos`);
    closers += '\n' + '  }'.repeat(diff);
  }

  const fixed = validJSON + closers;
  console.log('‚úÖ JSON fechado - tentando parsear...');

  return fixed;
}

// ‚úÖ TENTAR PARSE COM FECHAMENTO FOR√áADO
try {
  const fixed = forceCloseJSON(cleaned);
  const parsed = JSON.parse(fixed);

  console.log('‚úÖ PARSE BEM-SUCEDIDO!');
  console.log(`üìÖ Dias recuperados: ${parsed.trilha_editorial?.length || 0}`);

  return processarTrilha(parsed);

} catch (parseError) {
  console.error('‚ùå Parse falhou mesmo ap√≥s fechamento for√ßado');
  console.error('Erro:', parseError.message);

  // ‚úÖ PLANO B: Extrair objetos do array manualmente
  try {
    console.log('üîß PLANO B: Extraindo objetos v√°lidos do array...');

    const arrayMatch = cleaned.match(/"trilha_editorial"\s*:\s*\[([\s\S]*)/);
    if (!arrayMatch) {
      throw new Error('Array trilha_editorial n√£o encontrado');
    }

    const arrayContent = arrayMatch[1];
    const dias = [];

    // Extrair cada objeto do dia usando regex
    const diaPattern = /\{[^{}]*?"dia"\s*:\s*(\d+)[^{}]*?\}/g;
    let match;

    while ((match = diaPattern.exec(arrayContent)) !== null) {
      try {
        const diaObj = JSON.parse(match[0]);
        dias.push(diaObj);
      } catch (e) {
        console.log(`‚ö†Ô∏è Dia ${match[1]} ignorado - JSON inv√°lido`);
      }
    }

    console.log(`‚úÖ Extra√≠dos ${dias.length} dias v√°lidos via regex`);

    if (dias.length > 0) {
      const parsed = {
        trilha_editorial: dias,
        expert_id: cleaned.match(/"expert_id"\s*:\s*"([^"]+)"/)?.[1] || 'unknown',
        expert_name: cleaned.match(/"expert_name"\s*:\s*"([^"]+)"/)?.[1] || 'Unknown',
        estrategia_resumo: null,
        insights_estrategicos: null
      };

      return processarTrilha(parsed);
    }

  } catch (planBError) {
    console.error('‚ùå Plano B tamb√©m falhou:', planBError.message);
  }

  // ‚úÖ √öLTIMO RECURSO: Retornar erro com dados completos para debug
  return {
    json: {
      parsing_status: 'error',
      error_message: 'JSON truncado - agente n√£o completou os 30 dias',
      error_type: 'AGENT_OUTPUT_TRUNCATED',

      output_full: cleaned,
      output_length: cleaned.length,
      output_preview_start: cleaned.substring(0, 500),
      output_preview_end: cleaned.substring(Math.max(0, cleaned.length - 500)),

      structure_analysis: {
        open_braces: (cleaned.match(/{/g) || []).length,
        close_braces: (cleaned.match(/}/g) || []).length,
        open_brackets: (cleaned.match(/\[/g) || []).length,
        close_brackets: (cleaned.match(/\]/g) || []).length,
        quote_count: (cleaned.match(/"/g) || []).length
      },

      suggested_fix: 'O agente est√° truncando o output no meio do dia 7. Solu√ß√µes:\n' +
        '1. Aumentar max_tokens no agente\n' +
        '2. Pedir ao agente para gerar apenas 15 dias em vez de 30\n' +
        '3. Dividir em 2 chamadas: dias 1-15 e dias 16-30',

      trilha_texto: '‚ö†Ô∏è ATEN√á√ÉO: O agente parou de gerar no meio do dia 7. Veja suggested_fix.',
      estrategia_texto: '',
      insights_texto: '',
      calendario_texto: '',
      stats_texto: '',
      trilha_json: '[]',
      trilha_completa_json: '{}',
      dias_reels_json: '[]',
      expert_id: 'error',
      expert_name: 'Error',
      total_dias: 0,
      total_reels: 0,
      stats: {},
      data_geracao: new Date().toISOString()
    }
  };
}

// ========================================
// FUN√á√ÉO: PROCESSAR TRILHA
// ========================================
function processarTrilha(parsed) {
  console.log('üìã Processando trilha...');

  const trilhaArray = parsed.trilha_editorial || [];
  const diasComReels = trilhaArray.filter(d => d.formato_primario === 'Reel');

  console.log(`‚úÖ ${trilhaArray.length} dias | ${diasComReels.length} reels`);

  // ‚úÖ FORMATAR TRILHA
  const trilhaFormatada = trilhaArray.map(dia =>
    `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n` +
    `üìÖ DIA ${dia.dia} | ${dia.dia_semana} ${dia.data_sugerida}\n` +
    `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n` +
    `üéØ FASE: ${dia.fase}\n` +
    `üìå PILAR: ${dia.pilar}\n` +
    `üå°Ô∏è TEMPERATURA: ${dia.temperatura_lead}\n\n` +
    `üìù TEMA:\n${dia.tema}\n\n` +
    `üîç √ÇNGULO:\n${dia.angulo}\n\n` +
    `üé¨ FORMATO: ${dia.formato_primario}${dia.duracao_estimada ? ` (${dia.duracao_estimada})` : ''}\n\n` +
    `üé™ GATILHO: ${dia.gatilho_mental}\n` +
    `üéØ OBJETIVO: ${dia.objetivo}\n` +
    `üìä M√âTRICA: ${dia.metrica_sucesso}\n\n` +
    `üí° PONTOS:\n${(dia.pontos_chave || []).map((p, i) => `  ${i+1}. ${p}`).join('\n')}\n\n` +
    `ü™ù HOOK: "${dia.hook_sugerido || 'N/A'}"\n` +
    `üì£ CTA (${dia.cta_tipo}): ${dia.cta_texto || 'N/A'}\n`
  ).join('\n\n');

  // ‚úÖ STATS
  const stats = {
    total_dias: trilhaArray.length,
    total_reels: diasComReels.length,
    total_stories: trilhaArray.filter(d => d.formato_primario === 'Story').length,
    total_carrosseis: trilhaArray.filter(d => d.formato_primario === 'Carrossel').length,
    total_posts: trilhaArray.filter(d => d.formato_primario === 'Post').length,
    por_fase: {
      awareness: trilhaArray.filter(d => d.fase === 'Awareness').length,
      educacao: trilhaArray.filter(d => d.fase === 'Educa√ß√£o').length,
      diferenciacao: trilhaArray.filter(d => d.fase === 'Diferencia√ß√£o').length,
      conversao: trilhaArray.filter(d => d.fase === 'Convers√£o').length
    }
  };

  const statsFormatadas =
    `üìä ESTAT√çSTICAS\n\n` +
    `üìÖ Total: ${stats.total_dias} dias\n` +
    `üé¨ Reels: ${stats.total_reels} | Stories: ${stats.total_stories} | Carross√©is: ${stats.total_carrosseis}\n\n` +
    `üå°Ô∏è POR FASE:\n` +
    `  ‚Ä¢ Awareness: ${stats.por_fase.awareness}\n` +
    `  ‚Ä¢ Educa√ß√£o: ${stats.por_fase.educacao}\n` +
    `  ‚Ä¢ Diferencia√ß√£o: ${stats.por_fase.diferenciacao}\n` +
    `  ‚Ä¢ Convers√£o: ${stats.por_fase.conversao}`;

  const calendarioSimples = trilhaArray.map(dia =>
    `${dia.data_sugerida} (${dia.dia_semana}) | ${dia.formato_primario} | ${dia.tema}`
  ).join('\n');

  // ‚ö†Ô∏è AVISO se incompleto
  const aviso = trilhaArray.length < 30
    ? `\n\n‚ö†Ô∏è ATEN√á√ÉO: Trilha incompleta! Apenas ${trilhaArray.length}/30 dias foram gerados.\n` +
      `O agente provavelmente atingiu o limite de tokens. Considere:\n` +
      `- Aumentar max_tokens no agente\n` +
      `- Gerar em 2 partes (15 + 15 dias)\n`
    : '';

  return {
    json: {
      trilha_texto: trilhaFormatada + aviso,
      estrategia_texto: parsed.estrategia_resumo?.objetivo_mes || 'N/A',
      insights_texto: JSON.stringify(parsed.insights_estrategicos || {}, null, 2),
      calendario_texto: calendarioSimples,
      stats_texto: statsFormatadas + aviso,
      trilha_json: JSON.stringify(trilhaArray, null, 2),
      trilha_completa_json: JSON.stringify(parsed, null, 2),
      dias_reels_json: JSON.stringify(diasComReels, null, 2),
      expert_id: parsed.expert_id || 'unknown',
      expert_name: parsed.expert_name || 'Unknown',
      total_dias: stats.total_dias,
      total_reels: stats.total_reels,
      stats: stats,
      data_geracao: new Date().toISOString(),
      parsing_status: 'success',
      parsing_warning: trilhaArray.length < 30 ? 'trilha_incompleta' : null
    }
  };
}
